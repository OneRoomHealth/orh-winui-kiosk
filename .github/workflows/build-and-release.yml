name: Build and Release MSIX

on:
  push:
    tags:
      - 'v*.*.*'  # Trigger on version tags like v1.0.0
  workflow_dispatch:  # Allow manual triggering
    inputs:
      version:
        description: 'Version number (e.g., 1.0.0)'
        required: true
        default: '1.0.0'

env:
  PROJECT_PATH: KioskApp/KioskApp.csproj
  SOLUTION_NAME: OneRoomHealthKioskApp
  CONFIGURATION: Release
  PLATFORM: x64

jobs:
  build:
    runs-on: windows-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0.x'

    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@v2

    - name: Restore NuGet packages
      run: dotnet restore ${{ env.PROJECT_PATH }}

    - name: Decode and install signing certificate
      run: |
        # Decode the base64 certificate from secrets
        $pfxBytes = [System.Convert]::FromBase64String("${{ secrets.SIGNING_CERTIFICATE }}")
        $pfxPath = "${{ github.workspace }}\GitHubActionsWorkflow.pfx"
        [IO.File]::WriteAllBytes($pfxPath, $pfxBytes)
        
        # Import certificate to the local machine store
        # Use single quotes to prevent PowerShell variable expansion
        $passwordString = '${{ secrets.CERTIFICATE_PASSWORD }}'
        $certPassword = ConvertTo-SecureString $passwordString -AsPlainText -Force
        Import-PfxCertificate -FilePath $pfxPath -CertStoreLocation Cert:\CurrentUser\My -Password $certPassword
      shell: pwsh

    - name: Update version in Package.appxmanifest
      run: |
        # Extract version from tag or input
        $version = "${{ github.ref_name }}"
        if ($version -match '^v(.*)$') {
          $version = $matches[1]
        } elseif ("${{ github.event.inputs.version }}" -ne "") {
          $version = "${{ github.event.inputs.version }}"
        }
        
        # Ensure version is in X.Y.Z.W format
        if ($version -match '^\d+\.\d+\.\d+$') {
          $version = "$version.0"
        }
        
        Write-Host "Setting version to: $version"
        
        # Update Package.appxmanifest using XML manipulation to preserve encoding
        $manifestPath = "KioskApp/Package.appxmanifest"
        [xml]$manifest = Get-Content $manifestPath -Encoding UTF8
        $manifest.Package.Identity.Version = $version
        
        # Save with proper XML formatting and UTF-8 encoding
        $xmlSettings = New-Object System.Xml.XmlWriterSettings
        $xmlSettings.Indent = $true
        $xmlSettings.IndentChars = "  "
        $xmlSettings.Encoding = [System.Text.Encoding]::UTF8
        $xmlSettings.OmitXmlDeclaration = $false
        
        $xmlWriter = [System.Xml.XmlWriter]::Create($manifestPath, $xmlSettings)
        $manifest.Save($xmlWriter)
        $xmlWriter.Close()
        
        # Store version for later steps
        echo "APP_VERSION=$version" >> $env:GITHUB_ENV
      shell: pwsh

    - name: Build and Package MSIX
      run: |
        Write-Host "Starting MSIX package build..."
        
        # Build the project with package creation
        # The project file already has AppxBundle=Always configured
        msbuild ${{ env.PROJECT_PATH }} `
          /p:Configuration=${{ env.CONFIGURATION }} `
          /p:Platform=${{ env.PLATFORM }} `
          /p:AppxBundle=Always `
          /p:AppxBundlePlatforms="${{ env.PLATFORM }}" `
          /p:AppxPackageDir="${{ github.workspace }}\AppPackages\" `
          /p:UapAppxPackageBuildMode=SideloadOnly `
          /p:AppxPackageSigningEnabled=true `
          /p:PackageCertificateKeyFile="${{ github.workspace }}\GitHubActionsWorkflow.pfx" `
          /p:PackageCertificatePassword='${{ secrets.CERTIFICATE_PASSWORD }}' `
          /p:GenerateAppInstallerFile=false `
          /p:PublishProfile="" `
          /verbosity:normal `
          /restore
        
        if ($LASTEXITCODE -ne 0) {
          Write-Error "MSBuild failed with exit code $LASTEXITCODE"
          exit $LASTEXITCODE
        }
        
        Write-Host "`n========================================" 
        Write-Host "Build completed successfully"
        Write-Host "========================================`n"
        
        # List what was created in all possible locations
        Write-Host "Searching for generated MSIX files...`n"
        
        $appPackagesDir = "${{ github.workspace }}\AppPackages"
        if (Test-Path $appPackagesDir) {
          Write-Host "Contents of AppPackages directory:"
          Get-ChildItem -Path $appPackagesDir -Recurse | ForEach-Object { Write-Host "  $($_.FullName)" }
        }
        
        $binDir = "${{ github.workspace }}\KioskApp\bin"
        if (Test-Path $binDir) {
          Write-Host "`nMSIX files in bin directory:"
          Get-ChildItem -Path $binDir -Recurse -Filter "*.msix*" -ErrorAction SilentlyContinue | ForEach-Object { Write-Host "  $($_.FullName)" }
        }
        
        $objDir = "${{ github.workspace }}\KioskApp\obj"
        if (Test-Path $objDir) {
          Write-Host "`nMSIX files in obj directory:"
          Get-ChildItem -Path $objDir -Recurse -Filter "*.msix*" -ErrorAction SilentlyContinue | ForEach-Object { Write-Host "  $($_.FullName)" }
        }
      shell: pwsh

    - name: Find and rename MSIX bundle
      id: find_bundle
      run: |
        # Search for MSIX bundle in multiple possible locations
        Write-Host "Searching for MSIX bundle..."
        
        $searchPaths = @(
          "${{ github.workspace }}\AppPackages",
          "${{ github.workspace }}\KioskApp\AppPackages",
          "${{ github.workspace }}\KioskApp\bin",
          "${{ github.workspace }}\bin",
          "${{ github.workspace }}\KioskApp\obj\x64\Release\net8.0-windows10.0.19041.0\MsixContent"
        )
        
        $bundlePath = $null
        foreach ($searchPath in $searchPaths) {
          Write-Host "Checking: $searchPath"
          if (Test-Path $searchPath) {
            $found = Get-ChildItem -Path $searchPath -Filter "*.msixbundle" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
            if ($found) {
              $bundlePath = $found
              Write-Host "Found bundle at: $($bundlePath.FullName)"
              break
            }
          }
        }
        
        if ($null -eq $bundlePath) {
          Write-Host "MSIX bundle not found. Searching for individual MSIX files as fallback..."
          
        # Try to find Main.msix or any .msix file as fallback
        $msixFiles = Get-ChildItem -Path "${{ github.workspace }}" -Filter "*.msix" -Recurse -ErrorAction SilentlyContinue
        $mainMsix = $msixFiles | Where-Object { $_.Name -match "(Main|OneRoomHealthKioskApp)\.msix" } | Select-Object -First 1
          
          if ($mainMsix) {
            Write-Host "Found Main.msix file at: $($mainMsix.FullName)"
            Write-Host "Using Main.msix as the package (renaming to .msixbundle for compatibility)"
            $bundlePath = $mainMsix
          } else {
            Write-Host "No MSIX bundle or Main.msix found. Listing all files in search paths:"
            foreach ($searchPath in $searchPaths) {
              if (Test-Path $searchPath) {
                Write-Host "`nContents of $searchPath :"
                Get-ChildItem -Path $searchPath -Recurse -ErrorAction SilentlyContinue | ForEach-Object { Write-Host "  $($_.FullName)" }
              }
            }
            
            Write-Host "`nAll .msix* files found:"
            $msixFiles | ForEach-Object { Write-Host "  $($_.FullName)" }
            
            Write-Error "No usable MSIX package found!"
            exit 1
          }
        }
        
        $newBundleName = "${{ env.SOLUTION_NAME }}_${{ env.APP_VERSION }}_${{ env.PLATFORM }}.msixbundle"
        $newBundlePath = "${{ github.workspace }}\$newBundleName"
        
        Copy-Item -Path $bundlePath.FullName -Destination $newBundlePath
        Write-Host "Bundle created at: $newBundlePath"
        
        echo "BUNDLE_PATH=$newBundlePath" >> $env:GITHUB_ENV
        echo "BUNDLE_NAME=$newBundleName" >> $env:GITHUB_ENV
      shell: pwsh

    - name: Export certificate to .cer
      run: |
        # Export the certificate as .cer for distribution
        $pfxPath = "${{ github.workspace }}\GitHubActionsWorkflow.pfx"
        $cerPath = "${{ github.workspace }}\${{ env.SOLUTION_NAME }}_${{ env.APP_VERSION }}.cer"
        
        # Use X509Certificate2 constructor to load PFX with password
        $passwordString = '${{ secrets.CERTIFICATE_PASSWORD }}'
        
        # Load the certificate from PFX using constructor
        $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2($pfxPath, $passwordString, [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::DefaultKeySet)
        
        # Export as .cer (public certificate only)
        $bytes = $cert.Export([System.Security.Cryptography.X509Certificates.X509ContentType]::Cert)
        [System.IO.File]::WriteAllBytes($cerPath, $bytes)
        
        Write-Host "Certificate exported to: $cerPath"
        
        echo "CER_PATH=$cerPath" >> $env:GITHUB_ENV
      shell: pwsh

    - name: Update AppInstaller file
      run: |
        $version = "${{ env.APP_VERSION }}"
        $repoUrl = "${{ github.server_url }}/${{ github.repository }}"
        $bundleName = "${{ env.BUNDLE_NAME }}"
        $solutionName = "${{ env.SOLUTION_NAME }}"
        
        # Create AppInstaller content using string concatenation to avoid YAML conflicts
        $appInstallerContent = '<?xml version="1.0" encoding="utf-8"?>' + "`n"
        $appInstallerContent += '<AppInstaller' + "`n"
        $appInstallerContent += '    Uri="' + $repoUrl + '/releases/latest/download/' + $solutionName + '.appinstaller"' + "`n"
        $appInstallerContent += '    Version="' + $version + '"' + "`n"
        $appInstallerContent += '    xmlns="http://schemas.microsoft.com/appx/appinstaller/2018">' + "`n"
        $appInstallerContent += "`n"
        $appInstallerContent += '  <MainBundle' + "`n"
        $appInstallerContent += '      Name="' + $solutionName + '"' + "`n"
        $appInstallerContent += '      Publisher="CN=OneRoomHealth"' + "`n"
        $appInstallerContent += '      Version="' + $version + '"' + "`n"
        $appInstallerContent += '      Uri="' + $repoUrl + '/releases/latest/download/' + $bundleName + '" />' + "`n"
        $appInstallerContent += "`n"
        $appInstallerContent += '  <UpdateSettings>' + "`n"
        $appInstallerContent += '    <OnLaunch' + "`n"
        $appInstallerContent += '        HoursBetweenUpdateChecks="0"' + "`n"
        $appInstallerContent += '        ShowPrompt="false"' + "`n"
        $appInstallerContent += '        UpdateBlocksActivation="true" />' + "`n"
        $appInstallerContent += '    <AutomaticBackgroundTask />' + "`n"
        $appInstallerContent += '  </UpdateSettings>' + "`n"
        $appInstallerContent += '</AppInstaller>'
        
        $appInstallerPath = "${{ github.workspace }}\${{ env.SOLUTION_NAME }}.appinstaller"
        Set-Content -Path $appInstallerPath -Value $appInstallerContent -Encoding UTF8
        
        echo "APPINSTALLER_PATH=$appInstallerPath" >> $env:GITHUB_ENV
      shell: pwsh

    - name: Create Release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ github.ref_name }}
        name: Release ${{ env.APP_VERSION }}
        body: |
          ## Kiosk App v${{ env.APP_VERSION }}
          
          ### Installation Instructions
          
          #### First-time Installation:
          1. Download and install the certificate: `${{ env.SOLUTION_NAME }}_${{ env.APP_VERSION }}.cer`
             - Right-click â†’ Install Certificate
             - Choose "Local Machine"
             - Place in "Trusted People" store
          
          2. Install the app:
             ```powershell
             Add-AppxPackage -Path "${{ env.BUNDLE_NAME }}"
             ```
          
          #### Auto-Update Installation:
          ```powershell
          Add-AppxPackage -AppInstallerFile "${{ github.server_url }}/${{ github.repository }}/releases/latest/download/${{ env.SOLUTION_NAME }}.appinstaller"
          ```
          
          ### Files
          - **${{ env.BUNDLE_NAME }}** - The application bundle
          - **${{ env.SOLUTION_NAME }}.appinstaller** - Auto-update installer
          - **${{ env.SOLUTION_NAME }}_${{ env.APP_VERSION }}.cer** - Signing certificate
          
          Built on: ${{ github.event.head_commit.timestamp }}
        files: |
          ${{ env.BUNDLE_PATH }}
          ${{ env.APPINSTALLER_PATH }}
          ${{ env.CER_PATH }}
        draft: false
        prerelease: false
        token: ${{ secrets.RELEASE_TOKEN }}

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: MSIX-Package-${{ env.APP_VERSION }}
        path: |
          ${{ env.BUNDLE_PATH }}
          ${{ env.APPINSTALLER_PATH }}
          ${{ env.CER_PATH }}
        retention-days: 90

    - name: Cleanup certificates
      if: always()
      run: |
        Remove-Item -Path "${{ github.workspace }}\GitHubActionsWorkflow.pfx" -Force -ErrorAction SilentlyContinue
      shell: pwsh

